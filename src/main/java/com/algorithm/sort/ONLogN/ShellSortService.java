package com.algorithm.sort.ONLogN;

import com.algorithm.sort.ON2.InsertSortService;

/**
 * 希尔排序
 * 原理：插入排序的改进版本，由于插入排序有对“大部分有序的数组排序会很快”的特点 和 对数组元素数量少的排序快，进行优化，先进行预处理，将数组变成大部分有序。
 * 处理方式：对数组进行分组，间隔是数组总长度的一半，间隔称为希尔增量，对每组分别进行插入排序，这样处理后得到的数组比原来有序了，再如法炮制，2为希尔增量，分两组，每组4个元素
 * 直到希尔增量变为1也就是直接插入排序。
 *
 * 时间复杂度：O(N*LogN)
 * 复杂度分析：肯定是分logN轮了，每轮分为N/2组，每组2个数字进行1次排序
 *
 * 最坏时间复杂度：O(n2)
 * 最坏复杂度分析：当你用希尔增量去分隔的时候，发现分隔后的每个小组本来就是有序的，根本不用排序，如数组 2 1 5 3 7 6 9 8
 * 两两分组，4为希尔增量即数组的一半，结果是 23在一组 17, 56, 38，所以这次分组没用，白白浪费了分组的时间，最后就是直接插入排序的时间复杂度所以是 LogN + O(n2) = O(n2)
 *
 * 除了上面原因，他是不稳定排序的原因还有相同大小的元素，被它排序后会改变次序，如 5 8 6 5 4 2 1 7
 * 希尔增量为4，第一轮排序后 4 2 1 5 5 8 6 7
 * 原来的第一个5排到原来的第二个5后面去了
 *
 * 不稳定排序
 */
public class ShellSortService {


    public void sortv2(int[] array) {
        //希尔排序的增量
        int d=array.length;

        while (d> 1) {
            //使用希尔增量的方式，即每次折半，d即是分组间隔即希尔增量，也是组数
            d=d/2;

            // 这里的d代表组的概念，对每个分组进行遍历
            for(int x=0; x<d; x++) {
                // 这里就是一个插入排序，只不过把间隔从1变成d了，直接从组里第二个元素开始遍历，第一个忽略，所以是x+d而不是x
                for(int i=x+d; i<array.length; i=i+d) {
                    int temp=array[i];
                    int j;
                    for (j=i-d;j>= 0 && array[j]>temp;j=j-d) {
                        array[j+d]=array[j];
                    }
                    array[j+d]=temp;
                }
            }
        }
    }
}
